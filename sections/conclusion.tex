\chapter{Conclusion}
The existing recording system, MCLURS, has been redesigned such MCLURS can be used in new use cases requiring online processing and monitoring of recordings. Instead of saving recordings to files locally on each RPI, the new design utilizes multicast groups to distribute streams among those network nodes that want particular streams. From the Analysis a list of requirements where extracted and mapped into widely used streaming protocols with success. Four software components has been introduced that following from design requirements are modular by design and thereby makes it relative easy to interface MCLURS to the streams. The design has been tested by making a proof-of-concept implementations written in PERL, that using a C RTP library makes it possible to send streams of samples over a multicast group. This stream can then be received again and tested to be the exact same as the stream of samples that was sent. A mechanisms were implemented that takes care of multicast group collisions, however it turned out to be prone to deadlocks. A designated network node named a \hist{} has been defined to be responsible for recording and replaying streams. From a test, it was showed that the \hist{} is perfectly capable of recording streams and replaying them again without loosing or changing the order of packets. \\

\noindent{}As mentioned in chapter \ref{chp:discussion}, not all requirements have been successfully verified and some functionality has not been implemented, due to lack of time. Performance testing of the implementation has not been done either, however these results will be presented at exam\\

\noindent{} Overall the suggested architecture has proved to fulfill the requirements extracted from the use cases, but more time should be spend of pushing the suggested architecture to its limits.\\

\noindent{}For the future aspect of the project the list from the Discussion of features not fully implemented would be a good place to start. An EventHistorian could be implemented that allow the user to search through the events. If collected events are events saying when a bat is present, it could be useful to the biologist to be able to query the EventHistorian to get a list of e.g. the average number of bats during night-time. As the events are hierarchical key/value pairs, a NoSQL database could be used to store the event. Most NoSQL databases takes JSON encoded data as input meaning the events could be put directly into the NoSQL database. As  there is no inherent relation between events and anything else, there is no immediate need for a relational database.

