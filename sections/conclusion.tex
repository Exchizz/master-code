\chapter{Conclusion}
The existing recording system, MCLURS, has been redesigned such MCLURS can be used in new use cases requiring online processing and monitoring of recordings. Instead of saving recordings to files locally on each RPI, the new design utilizes multicast groups to distribute streams among those network nodes that want particular streams. From the Analysis a list of requirements where extracted and mapped into widely-used streaming protocols with success. Four software components have been introduced that follow from design requirements, are modular by design, and thereby make it relatively easy to interface MCLURS to the streams. The design has been tested by making proof-of-concept implementations written in PERL which, using a C RTP library make it possible to send streams of samples over a multicast group. This stream can then be received again and tested to be the exact same as the stream of samples that was sent. Mechanisms were implemented that take care of multicast group collisions; however, it turned out to be susceptible to deadlocks. A designated network node named a \hist{} has been defined to be responsible for recording and replaying streams. From a test, it was shown that the \hist{} is perfectly capable of recording streams and replaying them again without losing or changing the order of packets. \\

\noindent{}As mentioned in chapter \ref{chp:discussion}, not all requirements have been successfully verified and some functionality has not been implemented, due to lack of time. Performance testing of the implementation has not been done either; However these results will be presented at exam\\

\noindent{} Overall the suggested architecture has proved to fulfill the requirements extracted from the use cases, but more time should be spent pushing the suggested architecture to its limits.\\

\noindent{}For the future aspect of the project, the list from the Discussion of features not fully implemented would be a good place to start. An EventHistorian could be implemented that allows, the user to search through the events. If collected events are events saying when a bat is present, it could be useful to the biologist to be able to query the EventHistorian to get a list of e.g. the average number of bats during night-time. As the events are hierarchical key/value pairs, a NoSQL database could be used to store the event. Most NoSQL databases take JSON-encoded data as input meaning the events could be put directly into the NoSQL database. As  there is no inherent relation between events and anything else, there is no immediate need for a relational database.

