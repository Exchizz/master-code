\chapter{Implementation} \label{chp:implementation}
This chapter will describe the implementation of the \pub{} and \sub{} as designed in the chapter \ref{chp:design}. The chapter starts by comparing two RTP libraries which leads to the implementation of the \pubs{} and \sub{}. In order to show the modularity of the design and how the \pubs{} and \subs{} are integrated with MCLURs, three examples are provided. Appendix \ref{app:publisher} and \ref{app:subscriber} are the manpages of the \pub{} and \sub{}, respectively.

\section{Software Components}
The \pub{} and \sub{} have been implemented in PERL, as PERL is a nice language to make proof-of-concept implementations. PERL uses CPAN \footnote{\url{https://www.cpan.org/}} as package library meaning many modules are available for time conversion, protocols etc. PERL is chosen as it is the preferred scripting language of the author and because its an exciting language to truly master.\\

\noindent{}\pros{} and \cons{} written for testing are implemented in BASH. However, as described, any scripting as well as programming language could be used.\\

\noindent{} The \pro{} used for interacting with \program{Snapshot} is written in PERL as existing PERL code was available for talking to the \program{Snapshot} daemon.

\subsection{RTP/RTCP}
In order for the \pub{} and \sub{} to support sending and receiving RTP and RTCP messages a library should be used, in order not to implement parsing and composing of messages. By research, two C libraries have been found and compared. As PERL has support for wrapping C/C++ into PERL modules, one of the two modules can be integrated into the \subs{} and \pubs{}. The two libraries are oRTP and jrtplib.\\

\noindent{}\myparagraph{oRTP} 
The oRTP library is used in \textit{linphone Open-source VoIP}, which is an open-source VoIP solution created and maintained by Belledonne Communications. The oRTP library is released under the GNU GPLv2 and proprietary license meaning the library can be used for open-source projects and in proprietary solutions.
The oRTP library implements RFC3550 with an API that offers a high as well as low level interfacing for sending and receiving RTP and RTCP packets and parsing and composing RTP and RTCP packets. It supports multiple RTP sessions with IPv4 and IPv6 unicast and multicast. Furthermore, it offers support for different profiles, meaning a custom profile can be implemented.  oRTP has sparse documentation with only an autogenerated doxygen where most of the functionality is described. The source-code comes with simple examples that explain some of the library's functionality. The library is written in C and can be found in Ubuntu and Debian's package repository. At the time of writing the latest commit on their official github has been made 24 days ago which indicates the project is active. In CPAN, an oRTP library can be found that implements some of the most highest level API functions.


\myparagraph{jrtplib}
The jrtplib library is developed at the the Expertise Centre for Digital Media (EDM), a research institute of the Hasselt University. At the time of writing the library has been used in 61 projects listed on \href{http://research.edm.uhasselt.be/jori/cgi-bin/listprojects.py?name=jrtplib}{Project list}. The library is free to use, but must include a disclaimer in the source code. The library implements RFC3550 and provides primarily a high level API that hides most of the implementation details. The library supports parsing, composing, sending and receiving RTP and RTCP messages but does not not implement any profile, The library is written in C++ and well-documented by giving a thorough \textit{Getting Started} and includes 7 examples showing how to utilize the functionality of the library. Unfortunately, at the moment of writing the maintainers have not done any commits for the past year.

The libraries are compared based on the following requirements:
\begin{itemize}
	\item \textit{In repository}: From design requirement 4, the library should, if possible, be in the Debian repository.
	\item \textit{RTCP impl.}: The library should implement RTCP, as RTCP is required by the \pub{} and \sub{}.
	\item \textit{Low level API}: As the \pub{} and \sub{} should send RTCP SDEs, RTCP, BYE and RTCP SR.
	\item \textit{Custom RTP Profile}: The library should allow using a custom profile from requirement \ref{req:i:mdp:mdp}.
	\item \textit{API documented}: Preferable to ease implementation of the \pub{} and \sub{}.
	\item \textit{Actively Maintained}: Relatively important, in case bugs are discovered.
	\item \textit{IPv6/4 multicast support}: Described in section \ref{sec:streamingidea}.
	\item \textit{Existing PERL-binding}: As the \pub{} and \sub{} will be implemented in PERL, existing bindings are preferable to ease implementation.
	\item \textit{Multiple RTP sessions}: Required by requirement \ref{req:a:stream:session}
	\item \textit{Send \& Receive RTP/RTCP}: is required by \pub{} and \sub{}, respectively.
	\item \textit{Includes examples}: Preferable as it eases implementation.
\end{itemize}

\begin{table}[H]
\centering
\begin{tabular}{@{}|l|l|l@{}|}
\hline
\multicolumn{1}{|l|}{\textbf{Library property}} & \multicolumn{1}{|l|}{\textbf{oRTP}}         & \multicolumn{1}{|l|}{\textbf{jrtplib}}       \\ \midrule
\multicolumn{1}{|l|}{In repository}    & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{l|}{} \\ \midrule
\multicolumn{1}{|l|}{RTCP impl.} & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{Low level API} & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{} \\ \midrule
\multicolumn{1}{|l|}{Custom RTP Profile} & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{} \\ \midrule
\multicolumn{1}{|l|}{API documented}          & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{Actively Maintained}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{l|}{} \\ \midrule
\multicolumn{1}{|l|}{IPv6 multicast support}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{IPv4 multicast support}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{Existing PERL-binding}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{} \\ \midrule
\multicolumn{1}{|l|}{Multiple RTP sessions support}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{Send \& Receive}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{Includes examples}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark}  \\ \bottomrule
\end{tabular}
\caption{Comparesion of oRTP and jrtplib}
\label{sec:implementation:rtplib}
\end{table}

Based on the number of checkmarks in table \ref{sec:implementation:rtplib}, it has been chosen to use the oRTP library.

\subsection{Publisher \& Subscriber}

\textit{P1: The \pub{} should be the logical master of the \pro{}.}\\
\textit{S1: The \sub{} should be the logical master of the \pro{}.}\\

From requirement P1,S2 the \pub{} and \sub{} being the logical masters has been implemented by passing the path to the \con{} and \pro{} to the \sub{} and \pro{} respectively as an argument. This design allows the \pub{} and \sub{} to pass the pipes to the \pro{} and \con{} during run of the \con{} and \pro{}, respectively.

\begin{listing}[H] 
\begin{minted}{python}
./publisher.pl --producer producer.pl -- -v
./subscriber.pl --producer consumer.pl -- -v
\end{minted}
\caption{Example of publisher.pl run with producer.pl as parameter. -v will be passed to the \con{} and \pro{}}
Parameters specified after the -- is passed to the \con{}/\pro{}.
\label{lst:runcli}
\end{listing}

These will result in the process trees as depicted in figure \ref{sec:implementation:runmode}.

\begin{listing}[H] 
\begin{minted}{python}
/usr/bin/perl publisher.pl --producer producer.pl
 \_ /usr/bin/perl producer.pl /tmp/pub_data_pipe /tmp/pub_metadata_pipe -v
 
 /usr/bin/perl subscriber.pl --consumer consumer.pl
 \_ /usr/bin/perl consumer.pl /tmp/pub_data_pipe /tmp/pub_metadata_pipe -v
\end{minted}
\caption{Example of publisher.pl run as logical master of the producer.pl}
\label{sec:implementation:runmode}
\end{listing}

Running the consumer and producers this way gives modularity in the way the programs can be run, and does not restrict how the \con{} and \pro{} should be implemented.
Three examples described below show how the \pros{}, \cons{}, \pubs{} and \subs{} can be integrated with MCLURS and the streaming idea in section \ref{sec:streamingidea}.

\myparagraph{Grab with Static Metadatafile}
If \program{Grab} is used to produce data, the \con{} can be written as shown in listing \ref{lst:implementation:grab}. It should be noted that the \pro{} is a thin layer around \program{Grab}, that simply attaches \program{grab}'s stdout to the data pipe. See section \ref{sec:implementation:ipc} for more information about the named pipes.

\begin{listing}[H] 
\begin{minted}{bash}
#!/bin/bash
# Named pipes passed as parameters
DATA_PIPE=$1;shift;
MD_PIPE=$1; shift;

# Provide feedback to the user
echo "Starting producer"

# Set non-essential metadata to Publisher
cat metadata_example.json > $MD_PIPE

# Capture samples and write to datapipe with Fs of 250kHz
/usr/bin/grab -f 2500000 $* > $DATA_PIPE
\end{minted}
\caption{The listing shows an implementation of a \pro{} that writes metadata and samples to the datapipe and metadatapipe, respectively}
\label{lst:implementation:grab}
\end{listing}

\noindent{}Listing \ref{lst:implementation:grab} shows how the \pro{} could be integrated with \program{grab}.
Metadata is provided by reading the \textit{metadata\_example.json}, and writing it to the metadatapipe.
As \program{grab} does not provide timing of the samples, no RTCP SR messages can be sent.


\myparagraph{Snapshot with Dynamic Metadata}
In order to use the \pub{} and \pub{} with \program{Snapshot}, the \pro{} must instruct \program{Snapshot} to do repeating snapshots. Furthermore, the \program{Snapshot} must be told where it should write the samples to. This is shown as pseudocode in listing \ref{lst:implementation:snapshot1}.

\begin{listing}[H] 
\begin{minted}{python}
#!pseudocode

# Named pipes passed as parameters
DATA_PIPE=$1
MD_PIPE=$2

open MD_PIPE
write metadata.json to MD_PIPE

snapshot = ZMQ(SNAPSHOT)
snapshot.setup()
snapshot.start()
snapshot.snap(start=0,length=4096,count=100,stream=\$1)

PeriodicRun(1, updateNonessentialMetadata());


def getNonessentialMetadata():
	metadata = snapshot.getNonessentialMetaData()
	write metadata to MD_PIPE
	
\end{minted}
\caption{The listing shows an implementation of a \pro{} that writes metadata and samples to the datapipe and metadatapipe, respectively}
\label{lst:implementation:snapshot1}
\end{listing}

The setup(), start() and snap() methods implement commands used by \program{Snapshot} in order to set parameters, start recordings and write snapshots to the pipe.
A timer is created at line 16, which periodically queries the \program{Snapshot} daemon, in order to get timing information. From design requirement P10, the RTCP SR packets should be sent in order to timestamp the data stream. In order to do this, \program{Snapshot} allows ZMQ clients to query for timing information. When a \textit{Ztatus} command\footnote{Command implemented by the \program{Snapshot} daemon} is received, it sends a reply of the following format:


\begin{listing}[H] 
\begin{minted}{python}
OK Ztatus: WRITER Files 0, Xfr space 49152[ki spl]
READER ACTIVE hix: 0x0000000000824800 [spl]\ 
  tix: 000000000000000000 [spl] now: 0x00002c8008e4ee1e [ns]
\end{minted}
\caption{The listing shows an implementation of a \pro{} that writes metadata and samples to the metadatapipe and datapipe, respectively}
\label{lst:implementation:snapshot2}
\end{listing}

The important part of the reply is the \ac{HIX} and ``now''. ``Now'' is a monotonic timestamp starting at a random value, which corresponds to the \ac{HIX}. Conversion of this information into RTCP SR packets is described in section \ref{sec:design:rtcpsr}.

The converted timestamp and associated \ac{HIX} is sent via the metadatapipe as shown in line 18 to the \pro{}. In this case, the \pro{} is more than a thin layer, but it should be noted that the \pro{} never handles the data, it only parses the replies from \program{Snapshot}.
Figure \ref{fig:implementation:dynamicmetadata} shows how the \pub{} interacts with the \pro{} which again interacts with the \program{Snapshot} daemon.


\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{figures/impl_example_snapshot_overview}
        \caption{The figure shows the communication channels between the \pub{}, \pro{} and \program{Snapshot} daemon.}
        \label{fig:implementation:dynamicmetadata}
    \end{subfigure}
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
      %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{figures/impl_example_filter_overview}
        \caption{The figure shows the \textit{filter} is run by the \pub{} which is run by the \sub{}}
        \label{fig:implementation:filer}
    \end{subfigure}
\end{figure}

\myparagraph{Subscriber and Publisher with Filter}
As shown in the streaming idea section \ref{sec:streamingidea}, the system should be capable of handling a node that subscribes to a stream and produces a new one. This will now be referred to as a filter. This can be done as shown in figure \ref{fig:implementation:filer}. In order to do do this, the \sub{} should take the \pub{} as argument, which takes the filter as argument. Unfortunately this does not work just by running the programs as described, a thin layer encapsulating the \pub{} has to be used. Listing \ref{lst:implementation:filterrun} shows how the three commands should be invoked.


\begin{listing}[H] 
\begin{minted}{bash}
perl subscriber.pl --consumer publisher.sh -- --producer filter
\end{minted}
\caption{The listing shows how a filter can be run, using the \textit{publisher.pl} and \textit{subscriber.pl}}
\label{lst:implementation:filterrun}
\end{listing}

If the above command is run, the process tree in listing \ref{lst:implementation:filtertree} should be seen. Due to lack of time, this has not been tested.

\begin{listing}[H] 
\begin{minted}{bash}
/usr/bin/perl subscriber.pl --consumer publisher.sh -- --producer filter
\_/bin/bash publisher.sh /tmp/datapipe1 /tmp/mdpipe1 --producer filter
  \_ /usr/bin/perl publisher.pl --producer filter -- /tmp/datapipe1 /tmp/mdpipe1
    \_./filter /tmp/datapipe2 /tmp/mdpipe2 /tmp/datapipe1 /tmp/mdpipe1
\end{minted}
\caption{The listing shows how a filter can be run, that reads data and metadata from two pipes, and writes new data and metadata to two new pipes}
\label{lst:implementation:filtertree}
\end{listing}
As mentioned, a bash script must be implemented, that takes the first two arguments, the datapipe and metadatapipe, and passes them to the \textit{Publisher.pl} after the $--$. If this layer is not used, the two pipes will be passed to the \textit{Publisher.pl} and not the \textit{Filter}, At the end, \textit{filter} receives four pipes, two for data and metadata input and two for data and metadata output.

\subsection{RTCP SR Timing} \label{sec:design:rtcpsr}
In order to calculate the 64 bit NTP timestamp for the RTCP SR packet, some calculations and time conversions must be done. As mentioned in the foregoing, the \program{Snapshot} reports a time and \ac{HIX}. This is depicted in figure \ref{fig:implementation:rtcpsr}.\footnote{This figure is a redrawing of a sketch made by John Hallam}
\begin{figure}[H]
	\centering
	\includegraphics[width=0.9\textwidth]{figures/rtcp_sr_timing}
	\caption{The figure shows the samples in a stream, with head(HIX) and tail(TIX) pointers. It should be noted that the ``now'' is when sample pointed to by HIX is captured}\label{fig:implementation:rtcpsr}
\end{figure}

\program{Snapshot} timestamps the sample using the kernel's CLOCK\_MONOTONIC clock meaning the clock has a random offset but is always increasing and is thereby not affected by \ac{NTP} updates. In order to use the timestamp, this random offset has to be calculated. This calculation is shown below.

\begin{align}
	mon_1 &= parse(Ztatus).now \\
	realtime &= \text{now in UTC in seconds since epoch} \\
	mon_2 &= parse(Ztatus).now \\
	\text{UTC\_offset} &= realtime-(mon_1+mon_2)/2 
\end{align}
By getting the monotonic time before and after taking the realtime clock in UTC, the offset can be estimated by calculating the average of the monotonic time, when the realtime was captured. When the realtime clock in UTC of sample HIX should be estimated, ``now'' can simply be added to the offset.  If the calculation was done the other way around, the offset estimation would be prone to updates of NTP.

As defined in the audio/video profile, the 32 bit timestamp of the RTP packets should be randomly generated offsets which is incremented by the number of samples in the packet. This has been implemented by generating a random number for the offset, and adding 2048\footnote{The system has only been used with chunksize of 4096 bytes, and each sample is 2 byes} to each. When a RTCP SR packet is to be sent, the latest 32 bit timestamp has been saved, such that the latest RTP packet sent can be associated with the 64 bit NTP timestamp in the RTCP SR packet. In order to calculate the RTCP time of the latest sent RTP packet, the following equation\footnote{Equation formulated by John Hallam} has been used.
\begin{equation}
	\text{RTCP\_time} = now + Ts\cdot((latestRTP-\textit{randomRTPoffset})-HIX)+\textit{UTC\_offset}
\end{equation} 

``now'' is the timestamp at which HIX was received and Ts is the sample period.
As all timings are with respect to the linux epoch\footnote{00:00:00 UTC Thursday, 1 January 1970}, the timestamp must be converted into NTP timestamp  which pr. definitions is with respect to NTP epoch\footnote{00:00:00 UTC, January 1 1900}. After the conversion the \textit{RTCP\_time} can then be added to an RTCP SR packet together with the \textit{latestRTPtimestamp}. 
Unfortunately, this does not work. This is described in section \ref{sec:verify:rtcpsr}.

\subsection{Inter-Process Communication} \label{sec:implementation:ipc}
From requirement \ref{req:i:pub:mdpipe} and \ref{req:i:s:mdpipe}, the non-essential and essential metadata should be passed between the \pub{}/\sub{} and the \con{}/\pro{} using pipes. Three types of pipes are considered:
\begin{itemize}
	\item Named pipe: Named pipes or FIFO pipes in linux usually appear as files, which processes can read from and write to as part of \ac{IPC}. Named pipes are uni-directional, as one process opens the pipe for writing, and another process opens for reading. Having multiple readers from the named pipe is not supported.
	
	\item Unnamed pipe: Unamed pipes are used in Linux to chain input/output between processes. As with named pipes, unamed pipes are uni-direction. This is implemented such that standard output(stdout) from one process, is attached to standard in(stdin) to the next process in the chain. As with named pipe, no framing is required.
	
	\item UNIX socket: UNIX sockets work similar to network sockets in linux, but only locally. Many clients can connect to the same server using the UNIX sockets. A UNIX socket appear like a named pipe, as a file. The UNIX socket supports bi-directional communication. 
\end{itemize}

If the \pub{} should use unnamed pipes, an unnamed pipe should be created that attach the unnamed pipe to stdout from the \pro{}, such that data printed from the \pro{} would show up at the other end of the pipe, read by the \pub{}. Another unnamed pipe could be created, that would be attached to standard error(stderr), in order to have two communication channels to pass non-essential/essential metadata and data to the \pub{}. However this design does not allow the \pro{} to generate output, which could be helpful in development, testing and debugging of \pros{}. The same could be applied to the \sub{} and \con{}; however only one communication channel is available from the \sub{} to the \con{}, which is not enough in order to provide essential/non-essential metadata and data to the \con{}.

UNIX sockets are not used, as bidirectional communication is not needed. Due to simplicity and using existing Linux functionality, the communication between the \pubs{} \subs{} and \con{} and \pro{} is created using named pipes. 


\section{Publisher \& Subscriber Implementation} \label{sec:implementation:implpubsub}
From design requirements, the \pub{} and \sub{} should be implemented using events. Both programs have been implemented using the IO::Async PERL module\footnote{\url{https://metacpan.org/pod/IO::Async}}, as it supports streaming events, meaning events from a file descriptor and periodic events.

\noindent{}PERL methods used by both the \sub{} and the \pub{} has been put into a shared library. oRTP is installed in the system, but  NET::RTP, NET::RTCP\footnote{Found on author of NET::RTP's github: \url{https://github.com/njh/perl-net-rtp}} and Pubsub::Util are stored in a local shared folder named ``lib''. The file tree is shown in listing \ref{lst:implementation:filetree}.

\begin{listing}[H] 
	\begin{minted}{bash}
|--publisher
|   |-- lib
|   |   |--- Net
|   |   |   |-- RTCP
|   |   |   |   |-- Packet.pm
|   |   |   |-- RTCP.pm
|   |   |   |-- RTP
|   |   |   |   |-- Packet.pm
|   |   |   |-- RTP.pm
|   |   |-- PubSub
|   |       |-- Util.pm
|   |-- metadata_example.json
|   |-- producer.pl -> ../producer/dummy_producer.pl
|   |-- publisher.pl
|--subscriber
|   |-- consumer.sh
|   |-- lib -> ../publisher/lib
|   |-- subscriber.pl
\end{minted}
\caption{Listing shows the tree of the files used by the \sub{} and \pub{}}
\label{lst:implementation:filetree}
\end{listing}

\subsection{Publisher}
From requirement \ref{req:i:pub:events}, the following events have been implemented:
\begin{itemize}
	\item When an SDP packet is received from the well known multicast group.
	\item When an RTCP packet is received from the well known multicast group.
	\item When an RTCP packet is received from the source multicast group.
	\item When a packet is received from the datapipe from the \pro{}.
	\item When a packet is received from the metadatapipe from the \pro{}.
	\item A timer to send RTCP SDES packets.
	\item A timer to send RTCP SR packets.
	\item A timer to send SDP packets.
\end{itemize}

Listing \ref{lst:implementation:eventpublisher} shows the pseudocode of the event implementation in the \pub{}.
\begin{listing}[H] 
\begin{minted}{python}
eventHandler = eventLoop()
	
timerX = Timer(X, callback_sdes_Xsec)
timerY = Timer(Y, callback_sr_Ysec)
timerZ = Timer(Z, callback_sdp_Zsec)
	
eventHandler.add(timerX)
eventHandler.add(timery)
eventHandler.add(timerZ)
	
stream_wellknown_RTP  = getStream(wellknownMG_RTP_fd, callback_wellknown_SDP)
stream_wellknown_RTCP = getStream(wellknownMG_RTCP_fd, callback_wellknown_RTCP)

stream_source_RTCP    = getStream(sourceMG_RTCP_fd, callback_source_RTCP)
stream_sourcepipe     = getStream(source_pipe, callback_sourcepipe)
stream_metadatapipe   = getStream(metadata_pipe, callback_metadatapipe)	
	
eventHandler.add(stream_wellknown)
eventHandler.add(stream_source)
eventHandler.add(stream_sourcepipe)
eventHandler.add(stream_metadatapipe)
	
eventHandler.run()
\end{minted}
\caption{Listing shows the event implementation in pseudocode of the \pub{}. The callback methods are shown}
\label{lst:implementation:eventpublisher}
\end{listing}

From implementation requirement \ref{req:i:pub:params}, the \pub{} should take the following parameters:
\begin{itemize}
	\item sdprate=x (in seconds, default = 1)
	\item sdesrate=y (in seconds, default = 1)
	\item srrate=z (in seconds, default = 1)
\end{itemize}

This has been implemented, such that the \textit{Publisher.pl} can be run with the following parameters:
\begin{listing}[h] 
\begin{minted}{python}
perl publisher.pl --sdprate=1 --sdesrate=1 --srrate=1 --producer <producer>
\end{minted}
\caption{Listing shows the publisher is run with the supported parameters}
\label{lst:implementation:parameterspublisher}
\end{listing}

\subsubsection{Non-Essential Metadata} \label{sec:implementation:nonemd:pub}
In order for a \pro{} to send essential and non-essential metadata, the essential and non-essential metadata should be packet into a supported format, and written to the metadata pipe. The format is set by the \textit{--metadatafmt} parameter. The supported formats are dictated by the metadata profile in section \ref{sec:implementation:metadataprofile}. An example of a non-essential and essential metadata is shown in listing \ref{lst:implementation:nonessess}.

\begin{listing}[H] 
\begin{minted}{json}
{
	"essential":{
		"key1":"value1",
		"key2":"value2",
	},
	"nonessential": {
		"keyx":"valuex",
		"keyy":"valuey"
	}
}
\end{minted}
\caption{Listing shows example of JSON encoded essential and non-essential metadata parsed to a \pub{} by a \con{}}
\label{lst:implementation:nonessess}
\end{listing}

The \pub{} will split the \textit{nonessential} and \textit{essential} metadata into two variables. The non-essential will be sent periodically on the well known multicast group in an RTP packet.
The non-essential metadata will be encoded using \textit{Storable}, a PERL module from CPAN\footnote{\url{https://metacpan.org/pod/Storable}}, and the essential should be inserted into the SDP packet.
Both essential and non-essential metadata can be provided either once or several times.  From section \ref{sec:design:rtcpsr} where timing is added to the source stream, the ``HIX'' and ``now'' is periodically updated such that the \pub{} can calculate and insert the timestamps into the RTCP SR messages.
It should be noted that ``HIX'' and ``now'' are an exception to the non-essential metadata in general, as these two values are not sent as non-essential metadata to the well known multicast group, but are instead silently used by the \pub{}.

\subsubsection{Event} \label{sec:implementation:events:pub}
The events are intended to be sent the same way as non-essential metadata. Instead of writing to the metadatapipe, the \pro{} should write events to the datapipe. The\textit{--eventfmt} parameter specifies the format of the event passed by the \pro{} to the \pub{}. The \pub{} then encodes the event into Storable, a PERL CPAN module which can be parsed by a \sub{}. The Storable module supports all PERL structures such as hashes, lists etc.


\subsection{Subscriber}
From requirement \ref{req:i:sub:events}, the following events have been implemented:
\begin{itemize}
	\item When an SDP packet is received from the well known multicast group.
	\item When an RTCP packet is received from the well known multicast group.
	\item When an RTP packet is received from the source multicast group.
	\item When an RTCP packet is received from the source multicast group.
	\item A timer to send RTCP SDES packets.
\end{itemize}


Listing \ref{lst:implementation:eventsubscriber} shows the pseudocode of the event implementation in the \sub{}.
\begin{listing}[H] 
\begin{minted}{python}
eventHandler = eventLoop()
	
timerX = Timer(X, callback_sdes_Xsec)
	
eventHandler.add(timerX)
	
stream_wellknown_RTP  = getStream(welknownMG_RTP_fd, callback_wellknown_SDP)
stream_wellknown_RTCP = getStream(welknownMG_RTCP_fd, callback_wellknown_RTCP)

stream_source_RTP     = getStream(sourceMG_RTP_fd, callback_source_RTP)
stream_source_RTCP    = getStream(sourceMG_RTCP_fd, callback_source_RTCP)


eventHandler.add(stream_wellknown_RTP)
eventHandler.add(stream_wellknown_RTCP)

eventHandler.add(stream_source_RTP)
eventHandler.add(stream_source_RTCP)

	
eventHandler.run()
\end{minted}
\caption{Listing shows the event implementation in pseudocode of the \pub{}. The callback methods are shown}
\label{lst:implementation:eventsubscriber}
\end{listing}

From requirement \ref{req:i:sub:params}, the \sub{} should take the following parameters:

\begin{itemize}
	\item sdesrate=y (y in seconds, default = 1)
\end{itemize}

This has been implemented, such that the \textit{Subscriber.pl} can be run with the following parameters:
\begin{listing}[h] 
\begin{minted}{python}
perl subscriber.pl --sdesrate=1 --consumer <consumer>
\end{minted}
\caption{Listing shows the \sub{} is run with the supported parameters}
\label{lst:implementation:parametersubscriber}
\end{listing}


\noindent{}A complete list of the parameters of the \pub{} and \sub{} can be found in appendix \ref{app:publisher} and \ref{app:subscriber}, where the man pages are attached.

From requirement \ref{req:a:s:resolvemg}, the \sub{} should single-handedly find the multicast group from the name of a session. This has been implemented as shown as a parameter in the previous session. The parameter takes a regular expression which is matched against the \textit{Session Name} of the SDP. The first SDP that matches the \textit{Session Name} will be joined.


\subsection{Essential \& Non-Essential} \label{sec:implementation:esssub}
Essential metadata is received by the \sub{} when the SDP is received. Non-essential metadata is read by the  \con{} by reading from the metadata pipe. The format of the metadata is specified with the \textit{--metadatafmt} parameter.

\subsubsection{Events} \label{sec:implementation:eventssub}
Events are read like essential and non-essential metadata, but from the datapipe instead. The format of the event is chosen by the \textit{--eventfmt} parameter.


\subsection{Composing and Parsing RTCP \& RTP Packets}
The oRTP library is used for composing RTP and RTCP packets using the NET::oRTP PERL module available from CPAN \footnote{\url{https://metacpan.org/pod/Net::oRTP}}. However the NET::oRTP module did not provide lowlevel API functions needed by the \pub{} and \sub{} to send the RTCP SDR/SR/BYE packets manually. The highlevel API could not be integrated with IO::Async, as the oRTP library runs its own scheduler to send and receive RTP/RTCP packets. Therefore, new methods where added to the NET::oRTP library. These methods are listed below:

\begin{itemize}
	\item raw\_rtcp\_bye\_send(session, reason): Used to send the RTCP BYE packet when the \pub{} or \sub{} is shutting down gracefully.
	\item raw\_rtcp\_sdes\_send(session): Sends the RTCP SDES packet. The items are filled in using set\_sdes\_items.
	\item set\_sdes\_items(session, cname): Used to set the \ac{CNAME} in the SDES packet.
	\item raw\_rtcp\_sr\_send(session, ntpTimestamp): used to send the 64 bit timestamp. The oRTP library keeps track of the RTP timestamp of the last send RTP message.
	\item raw\_rtp\_send(session, payload): used to send an RTP packet.
\end{itemize}
The ``sesson'' is passed by PERL, when the methods are run on an object representing an RTP session. In order to use the IO::Async event loop to handle incoming RTP and RTCP packets, the parser implemented in the oRTP library was not used due to oRTP lib's own scheduler. All RTP/RTCP sockets are created by oRTP lib, but the file descriptors are passed from the oRTP library to IO::Async's list of file descriptors to wait for.  NET::RTP\footnote{\url{https://metacpan.org/pod/Net::RTP}} and NET::RTCP \footnote{\url{https://github.com/njh/perl-net-rtp} - Written by the same guy as NET::RTP} were used to parse the received packets with success.\\

\noindent{}From requirement \ref{req:a:pub:localmcast}, the multicast traffic should also work on a virtual interface. In order for this to work, the IPV6\_MULTICAST\_LOOP\footnote{\url{https://docs.oracle.com/cd/E19683-01/806-4125/sockets-13/index.html}} option of the socket must be set to 1. This is supported by the set\_multicast \_loopback(session, enable) method available in the NET::oRTP library.

%\section{Metadata}
%Metadata must be provided by the \pro{}, as the \pro{} should be implemented to collect essential and non-essential metadata.
%\subsection{Essential Metadata}
%\subsection{Non-Essential Metadata}
%\subsection{Events}


%\todo{Describe essential and non-essential metadata}
\section{Historian}
As described in section \ref{sec:design:historian}, \program{tcpdump/tcpreplay} is used as \hist{}.
In order to record RTP and RTCP packets, \program{tcpdump} is shown in listing \ref{cmd:implementation:tcpdump}.
\begin{listing}[h] 
\begin{minted}{bash}
tcpdump -i interface -w /tmp/filedump.pcap dst port 5004 or dst port 5005 
\end{minted}
\caption{Listing shows how tcpdump is run to record RTP and RTCP packets. Port 5004 and 5005 is used for RTP and RTCP respectively}
\label{cmd:implementation:tcpdump}
\end{listing}


For replaying a recording, \program{tcpreplay} is used as showed in listing \ref{cmd:implementation:tcpreplay}. --enet-smac is used to change the MAC-address of all the packets such that they come from the right MAC-address of the physical machine replaying the packets.
\begin{listing}[h] 
	\begin{minted}{bash}
tcpreplay-edit -i eth0 --enet-smac <MAC of eth0> file1.pcap file2.pcap ...
	\end{minted}
\caption{Listing shows how tcpdump is run to record RTP and RTCP packets. Port 5004 and 5005 is used for RTP and RTCP respectively}
\label{cmd:implementation:tcpreplay}
\end{listing}

\section{Metadata profile} \label{sec:implementation:metadataprofile} 
A profile must be defined, in order to define a new set of parameters for the RTP packet such that RTP packets can carry SDP files, non-essential metadata and events. At the moment of writing, the metadata profile inherits all properties from the audio/video profile, however the semantics of the  \textit{Marker}-bit field has changed.

\begin{itemize}
	\item \textbf{Marker bit}: Denotes whether the RTP packet announces a new session with essential metadata or provides non-essential metadata.
		\begin{itemize}
			\item 0, the RTP packet announces a stream. 
			\item 1, the RTP packet contains non-essential metadata.
		\end{itemize}
\end{itemize}


For encoding of non-essential, essential metadata and events only JSON and YML is currently supported.
More details should be added if RTP fields are used for purposes other than the Audio/Video profile defines. When an event is sent, is should follow the example shown in listing \ref{lst:implementation:metadataprofile:example}.

\begin{listing}[h] 
\begin{minted}{json}
{
	"Start": "Start of event",
	"Duration": "Duration can be in any unit",
	"Data": {}
}
\end{minted}
\caption{Listing shows an example of a JSON encoded event}
\label{lst:implementation:metadataprofile:example}
\end{listing}
The timeformat and unit of start and duration should be specified in the non-essential metadata. An example is listed below.

\begin{listing}[h] 
\begin{minted}{json}
{
	"nonessential": {
		"event": {
			"Start":"ISO8601",
			"Duration":"[s]"
		}
	}
}
\end{minted}
\caption{Listing shows an example of nonessential metadata describing the units and timeformat of an event.}
\label{lst:implementation:metadataprofileunits}
\end{listing}

When events are sent using the metadata profile, MDP(metadata profile) should be added to the media line, starting with key \textbf{m=} in the SDP file. An example of this is shown in listing \ref{sec:implementation:mdp}:

\begin{listing}[h] 
\begin{minted}{bash}
m=metadata 5004/2 RTP/MDP
\end{minted}
\caption{Listing shows example of medialine in SDP announcing a session that sends events}
\label{cmd:implementation:mdp}
\end{listing}

\section{Multicast IP} \label{sec:implementation:multicastip}
Multicast for IPv4 and IPv6 does not work for all ranges of IPs, but only for a certain range allocated for multicast traffic.\footnote{\url{https://en.wikipedia.org/wiki/Multicast\_address}} 
A subset of this range is assigned to be used on a local network. 
A thorough description of the IP addresses are out of the scope of this thesis. 
For the SAP protocol\citep{RFC2974} the highest IP in the IPv4 Administrative Scope is used for announcements: 239.0.0.0 to 239.255.255.255. For the data multicast group, the 224.0.0.0 to 224.0.0.255 range can be used.

\noindent{}For IPv6 SAP uses FFYX:0:0:0:0:0:2:7FFE for session announcements. The scope of the IPv6, the X, should be set to the same scope as the actual data multicast groups such that when a participant receives a session announcement, it can join the data multicast group. The Y should be set to zero, as this means the session announcement is broadcasted. If Y is set to 1, only hosts that has joined that particular group receives the session announcement. FF is assigned to multicast addresses. For data multicast groups, any IP starting with FF1X:: can be used, where X is the scope.

\noindent{}Throughout the test verification section, FF15::beef has been used for announcements and FF15::random has been used for data multicast groups.


%\section{Software Components}
%The following examples are made in order to show the modularity of the system:

%\section{Test}
%From wireshark after resample:
%4096 = payload
%8 bytes = data gram
%12 bytes rtp header
%
%4116 bytes i total





%\input{sections/verification}

