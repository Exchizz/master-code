\chapter{Implementation} \label{chp:implementation}
This chapter will describe the implementation of the \pub{} and \sub{} as designed in the chapter \ref{chp:design}.\todo{Maybe add some more}. When referring to a requirement from the design chapter, the reference will be e.g. P1 and S1 for the \pub{} and \sub{}, respectively.

\section{Software Components}
The \pub{} and \sub{} has been implemented in PERL, as PERL is a nice language to make proof-of-concept implementations. PERL uses CPAN \footnote{\url{https://www.cpan.org/}} as package library meaning many modules are available for timeconversion, protocols etc. PERL is chosen as it is the preferred scripting language by the author and because its an exiting language to truly master.\\

\noindent{}\pro{} and \cons{} written for testing is implemented in BASH, however as described, any scripting as well as programming language could be used.\\

\noindent{} The \pro{} used for interacting with \program{Snapshot} is written in PERL as existing PERL code were available for talking to the \program{Snapshot} daemon.

\subsection{RTP/RTCP}
In order for the \pub{} and \sub{} to support sending and receiving RTP and RTCP messages a library should be used, in order not to implement parsing and composing of messages. By research, two C libraries have been found and compared. As PERL has support for wrapping C/C++ into PERL modules, one of the two modules can be integrated into the \subs{} and \pubs{}. The two libraries are oRTP and jrtplib.\\

\noindent{}\myparagraph{oRTP} 
The oRTP library is used in \textit{linphone Open-source VoIP}, which is an open-source VoIP solution created and maintained by Belledonne Communications. The oRTP library is released under the GNU GPLv2 and proprietary license meaning the library can be used for open-source projects and in proprietary solutions.
The oRTP library implements RFC3550 with an API that offers a high as well as low level interfacing for sending and receiving RTP and RTCP packets and parsing and composing RTP and RTCP packets. It supports multiple RTP sessions with IPv4 and IPv6 unicast and multicast. Furthermore, it offers support for different profiles, meaning a custom profile can be implrunmodeemented.  oRTP has a sparse documentation with only an autogenerated doxygen, where most of the functionality is described. The source-code comes with simple examples, that explains some of the library's functionality. The library is written in C and can be found in Ubuntu and Debian's packet repository. At the time of writing, the latest commit on their official github has been made 24 days ago which indicates the project is active. In CPAN, an oRTP library can be found, that implements some of the most high level API functions.


\myparagraph{jrtplib}
The jrtplib library is developed at the the Expertise Centre for Digital Media (EDM), a research institute of the Hasselt University. At the time of writing the library has been used in 61 projects listed on \href{http://research.edm.uhasselt.be/jori/cgi-bin/listprojects.py?name=jrtplib}{Project list}. The library is free to use, but must include disclaimer in the source code. The library implements RFC3550 and provides primarily a high level API, that hides most of the implementation details. The library supports parsing, composing, sending and receiving RTP and RTCP messages but does not not implement any profile, The library is written in C++ and well-documented by giving a thoroughly \textit{Getting Started} and includes 7 examples showing how to utilize the functionality of the library. Unfortunately, at the moment of writing the maintainers have not done any commits for the past year.

The libraries are compared based on the following requirements:
\begin{itemize}
	\item \textit{In repository}: From design requirement 4, the library should, if possible, be in the Debian repository.
	\item \textit{RTCP impl.}: The library should implement RTCP, as RTCP is required by the \pub{} and \sub{}.
	\item \textit{Low level API}: As the \pub{} and \sub{} should send RTCP SDEs, RTCP, BYE and RTCP SR.
	\item \textit{Custom RTP Profile}: The library should allow using a custom profile, as the \pub{} and \sub{} requires a custom profile for the non-essential/essential metadata.\todo{Verify requirement}
	\item \textit{API documented}: Preferable to ease implementation of the \pub{} and \sub{}
	\item \textit{Actively Maintained}: Relatively important, in case bugs are discovered.
	\item \textit{IPv6/4 multicast support}: Required by requirement X \todo{Analysis requirement}
	\item \textit{Existing per-binding}: As the \pub{} and \sub{} will be implemented in perl, existing bindings are preferable to ease implementation.
	\item \textit{Multiple RTP session}: Required by design requirement X
	\item \textit{Send \& Receive RTP/RTCP}: is required by \pub{} and \sub{}, respectively.
	\item \textit{Includes examples}: Preferable as it eases implementation.
\end{itemize}

\begin{table}[H]
\centering
\begin{tabular}{@{}|l|l|l@{}|}
\hline
\multicolumn{1}{|l|}{\textbf{Library property}} & \multicolumn{1}{|l|}{\textbf{oRTP}}         & \multicolumn{1}{|l|}{\textbf{jrtplib}}       \\ \midrule
\multicolumn{1}{|l|}{In repository}    & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{l|}{} \\ \midrule
\multicolumn{1}{|l|}{RTCP impl.} & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{Low level API} & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{} \\ \midrule
\multicolumn{1}{|l|}{Custom RTP Profile} & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{} \\ \midrule
\multicolumn{1}{|l|}{API documented}          & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{Actively Maintained}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{l|}{} \\ \midrule
\multicolumn{1}{|l|}{IPv6 multicast support}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{IPv4 multicast support}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{Existing perl-binding}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{} \\ \midrule
\multicolumn{1}{|l|}{Multiple RTP sessions support}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{Send \& Receive}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{Includes examples}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark}  \\ \bottomrule
\end{tabular}
\caption{Comparesion of oRTP and jrtplib}
\label{sec:implementation:rtplib}
\end{table}

Based on the number of checkmarks in table \ref{sec:implementation:rtplib}, it has been chosen to use the oRTP library.

\todo{File tree, describe common perl library}
\subsection{Publisher \& Subscriber}

\textit{P1: The \pub{} should be the logical master of the \pro{}}\\
\textit{S1: The \sub{} should be the logical master of the \pro{}}\\

From requirement P1,S2 the \pub{} and \sub{} being the logical masters has been implemented by passing the path to the \con{} and \pro{} to the \sub{} and \pro{} respectively as an argument. This design allows the \pub{} and \sub{} to pass the pipes to the \pro{} and \con{} during run of the \con{} and \pro{}, respectively.

\begin{listing}[H] 
\begin{minted}{python}
./publisher.pl --producer producer.pl -- -v
./subscriber.pl --producer consumer.pl -- -v
\end{minted}
\caption{Example of publisher.pl run with producer.pl as parameter}
\label{code:critical_section_c}
\end{listing}

This will result in the process tree as depicted in figure \ref{sec:implementation:runmode}.

\begin{listing}[H] 
\begin{minted}{python}
/usr/bin/perl publisher.pl --producer producer.pl
 \_ /usr/bin/perl producer.pl /tmp/pub_data_pipe /tmp/pub_metadata_pipe -v
 
 /usr/bin/perl subscriber.pl --consumer consumer.pl
 \_ /usr/bin/perl consumer.pl /tmp/pub_data_pipe /tmp/pub_metadata_pipe -v
\end{minted}
\caption{Example of publisher.pl run as logical master of the producer.pl}
\label{sec:implementation:runmode}
\end{listing}

By running the consumer and producers this way gives modularity in the way the programs can be run, and does not restrict how the \con{} and \pro{} should be implemented.
Three examples shows how the \pros{}, \cons{}, \pros{} and \subs{} can be integrated with MCLURS and the streaming idea in section \ref{sec:streamingidea}.

\myparagraph{Grab with static metadata file}
If \program{Grab} is used to produce data, the \con{} can be written as shown in listing \ref{lst:implementation:grab}. It should be noted that the \pro{} is a thin layer around \program{Grab}, that simply attaches \program{grab}'s stdout, to the data pipe. See section \ref{sec:implementation:ipc} for more information about the named pipes.

\begin{listing}[H] 
\begin{minted}{bash}
#!/bin/bash
# Named pipes passed as parameters
DATA_PIPE=$1
MD_PIPE=$2

# Provide feedback to the user
echo "Starting producer"

# Set non-essential metadata to Publisher
cat metadata_example.json > $MD_PIPE

# Capture samples and write to datapipe with Fs of 250kHz
/usr/bin/grab -f 2500000 > $DATA_PIPE
\end{minted}
\caption{The listing shows an implementation of a \pro{} that writes metadata and samples to the datapipe and metadatapipe, respectively}
\label{lst:implementation:grab}
\end{listing}

\noindent{}Listing \ref{lst:implementation:grab} shows how the \pro{} could be integrated with \program{grab}.
Metadata is provided by reading the \textit{metadata\_example.json}, and writing it to the metadatapipe.
As \program{grab} does not provide timing of the samples, no RTCP SR messages can be sent.


\myparagraph{Snapshot with Dynamic Metadata}
In order to use the \pub{} and \con{} with \program{Snapshot}, the \pro{} must instruct \program{Snapshot} to do repeating snapshots. Furthermore, the \program{Snapshot} must be told where it should write the samples to. This is shown as pseudocode in listing \ref{lst:implementation:snapshot1}.

\begin{listing}[H] 
\begin{minted}{python}
# Named pipes passed as parameters
DATA_PIPE=$1
MD_PIPE=$2

open MD_PIPE
write metadata.json to MD_PIPE

snapshot = ZMQ(SNAPSHOT)
snapshot.setup()
snapshot.start()
snapshot.snap(start=0,length=4096,count=100,stream=\$1)

PeriodicRun(1, updateNonessentialMetadata());


def getNonessentialMetadata():
	metadata = snapshot.getNonessentialMetaData()
	write metadata to MD_PIPE
	
\end{minted}
\caption{The listing shows an implementation of a \pro{} that writes metadata and samples to the datapipe and metadatapipe, respectively}
\label{lst:implementation:snapshot1}
\end{listing}

The setup(), start() and snap() methods implement commands used by \program{Snapshot}, in order to set parameters, start recordings and write snapshots to the pipe.
A periodic timer is created at line 16, which periodically queries the \program{Snapshot} daemon, in order to get timing information. From design requirement P10, the RTCP SR packets should be sent in order to timestamp the data stream. In order to do this, \program{Snapshot} supports ZMQ clients to query for timing information. When a \textit{Ztatus} command\footnote{Command implemented by the \program{Snapshot} daemon} is received, it sends a reply of the following format:


\begin{listing}[H] 
\begin{minted}{python}
OK Ztatus: WRITER Files 0, Xfr space 49152[ki spl]
READER ACTIVE hix: 0x0000000000824800 [spl]\ 
  tix: 000000000000000000 [spl] now: 0x00002c8008e4ee1e [ns]
\end{minted}
\caption{The listing shows an implementation of a \pro{} that writes metadata and samples to the metadatapipe and datapipe, respectively}
\label{lst:implementation:snapshot1}
\end{listing}

The important part of the reply is the \ac{HIX} and ''now``. ''Now`` is a monotonic timestamp starting at a random value, which corresponds to the \ac{HIX}. Conversion of this information into RTCP SR packets is described in section \ref{sec:design:rtcpsr}.

The converted timestamp and associated \ac{HIX} is sent via the metadatapipe as shown in line 18 to the \pro{}. In this case, the \pro{} is more than a thin layer, but it should be noted that the \pro{} never handles the data, it only parses the pipe to the \program{Snapshot}.
Figure \ref{fig:implementation:dynamicmetadata} shows how the \pub{} interacts with the \pro{} which again interacts with the \program{Snapshot} daemon.


\begin{figure}[H]
    \centering
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{figures/impl_example_snapshot_overview}
        \caption{The figure shows the communication channels between the \pub{}, \pro{} and \program{Snapshot} daemon.}
        \label{fig:implementation:dynamicmetadata}
    \end{subfigure}
    ~ %add desired spacing between images, e. g. ~, \quad, \qquad, \hfill etc. 
      %(or a blank line to force the subfigure onto a new line)
    \begin{subfigure}[b]{0.45\textwidth}
        \includegraphics[width=\textwidth]{figures/impl_example_filter_overview}
        \caption{The figure shows the \textit{filter} is run by the \pub{} which is run by the \sub{}}
        \label{fig:implementation:filer}
    \end{subfigure}
\end{figure}

\myparagraph{Subscriber and Publisher with Filter}
As shown in the streaming idea section \ref{sec:streamingidea}, the system should be capable of handling a node that subscribers to a stream, and produces a new one. This will now be referred to as a filter. This can be done as showed in figure \ref{fig:implementation:filer}. In order to do do this, the \sub{} should take the \pub{} as argument, which takes the filter as argument. Unfortunately this does not work just by running the programs as described, a thin  later encapsulating the \pub{} has to be used. Listing \ref{lst:implementation:filterrun} shows how the three commands should be invoked.


\begin{listing}[H] 
\begin{minted}{bash}
perl subscriber.pl --consumer publisher.sh -- --producer filter
\end{minted}
\caption{The listing shows how a filter can be run, using the \textit{publisher.pl} and \textit{subscriber.pl}}
\label{lst:implementation:filter}
\end{listing}

If the above command is run, the process tree in listing \ref{lst:implementation:filtertree} should be seen. Due to lack of time, this has not been tested.

\begin{listing}[H] 
\begin{minted}{bash}
/usr/bin/perl subscriber.pl --consumer publisher.sh -- --producer filter
\_/bin/bash publisher.sh /tmp/datapipe1 /tmp/mdpipe1 --producer filter
  \_ /usr/bin/perl publisher.pl --producer filter -- /tmp/datapipe1 /tmp/mdpipe1
    \_./filter /tmp/datapipe2 /tmp/mdpipe2 /tmp/datapipe1 /tmp/mdpipe1
\end{minted}
\caption{The listing shows how a filter can be run, that reads data and metadata from two pipes, and writes new data and metadata to two new pipes}
\label{lst:implementation:filter}
\end{listing}
As mentioned, a bash script must be implemented, that takes the first two arguments, the datapipe and metadatapipe, and passes them to the \textit{Publisher.pl} after the $--$. If this layer is not used, the two pipes will be passed to the \textit{Publisher.pl} and not the \textit{Filter}, At the end, \textit{filter} receives four pipes, two for data and metadata input and two for data and metadata output.

\subsubsection{RTCP SR Timing} \label{sec:design:rtcpsr}
In order to calculate the 64 bit NTP timestamp for the RTCP SR packet, some calculations and time conversions must be done. As mentioned in the previous, the \program{Snapshot} reports a time and \ac{HIX}. This is depicted in figure \ref{fig:implementation:rtcpsr}.\footnote{This figure is a redrawing of a sketch made by John Hallam}
\begin{figure}[H]
	\centering
	\includegraphics[width=\textwidth]{figures/rtcp_sr_timing}
	\caption{The figure shows the samples in a stream, with head(HIX) and tail(TAI) pointers. It should be noted that the ''now`` is when sample pointed to by HIX is captured}\label{fig:implementation:rtcpsr}
\end{figure}

\program{Snapchat} timestamps the sample using CLOCK\_MONOTONIC meaning the clock has a random offset but is always increasing and is thereby not affected by \ac{NTP} updates. In order to use the timestamp, this random offset has to be calculated. This calculation is shown below.

\begin{align}
	mon_1 &= parse(Ztatus).now \\
	realtime &= \text{now in UTC in seconds since epoch} \\
	mon_2 &= parse(Ztatus).now \\
	offset &= realtime-(mon_1+mon_2)/2 
\end{align}
By getting the monotonic time before and after taking the realtime clock in UTC, the offset can be estimated by calculating the average of the monotonic time, when the realtime was captured. When the realtime clock in UTC of sample HIX should be estimated, ''now`` can simply be added to the offset. 


\subsubsection{Inter-Process Communication} \label{sec:implementation:ipc}
From implementation requirement P2/S2, the non-essential and essential metadata should be passed between the \pub{}/\sub{} and the \con{}/\pro{} using pipes. Three types of pipes are considered:
\begin{itemize}
	\item Named pipe: Named pipes or FIFO pipes in linux usually appear as files, which processes can read from and write to as part of \ac{IPC}. Named pipes are uni-directional, as one process opens the pipe for writing, and another process opens for reading. Having multiple readers from the named pipe is not supported.
	
	\item Unnamed pipe: Unamed pipes are used in linux to chain input/output between processes. As with named pipes, unamed pipes are uni-direction. This is implemented such that standard output(stdout) from one process, is attached to standard in(stdin) to the next process in the chain. As with named pipe, no framing is required.
	
	\item UNIX socket: UNIX sockets work similar to network sockets in linux, but only locally. Many clients can connect to the same server using the UNIX sockets. A UNIX socket appear like a named pipe, as a file. The UNIX socket supports bi-directional communication. 
\end{itemize}

If the \pub{} should use unnamed pipes, an unnamed pipe should be created that attach the unnamed pipe to stdout from the \pro{}, such that data printed from the \pro{} would show up at the other end of the pipe, read by the \pub{}. Another unnamed pipe could be created, that would be attached to standard error(stderr), in order to have two communication channels to pass non-essential/essential metadata and data to the \pub{}. However this design does not allow the \pro{} to generate output, which could be helpful in development, testing and debugging of \cons{}. The same could be applied to the \sub{} and \con{}; however only one communication channel is available from the \sub{} to the \con{}, which is not enough in order to provide essential/non-essential and data to the \con{}.

Unix pipes are not used, as bidirectional communication is not needed. Due to simplicity and using existing linux functionality, the communication between the \pubs{} \subs{} and \con{} and \pro{} is created using named pipes.


\subsection{Publisher}
\subsection{Subscriber}
%\subsection{Runmode}


\section{Metadata}
Metadata must be provided by the \pro{}, as the \pro{} should be implemented to collect essential and non-essential metadata.


\section{Historian}
As described in section \ref{sec:design:historian}, \program{tcpdump/tcpreplay} is used as \hist{}.
In order to record RTP and RTCP packets, \program{tcpdump} is shown in listing \ref{cmd:implementation:tcpdump}.
\begin{listing}[h] 
\begin{minted}{bash}
tcpdump -i interface -w /tmp/filedump.pcap dst port 5004 or dst port 5005 
\end{minted}
\caption{Listing shows how tcpdump is run to record RTP and RTCP packets. Port 5004 and 5005 is used for RTP and RTCP respectively}
\label{cmd:implementation:tcpdump}
\end{listing}


For replaying a recording, \program{tcpreplay} is used as showed in listing \ref{cmd:implementation:tcpreplay}.
\begin{listing}[h] 
	\begin{minted}{bash}
tcpreplay-edit -i eth0 --enet-smac <MAC of eth0> <file1.p
	\end{minted}
\caption{Listing shows how tcpdump is run to record RTP and RTCP packets. Port 5004 and 5005 is used for RTP and RTCP respectively}
\label{cmd:implementation:tcpreplay}
\end{listing}
\todo{Fix command}


The file tree of the \pub{} and \sub{} is shown in listing \ref{lst:implementation:tree}.
\begin{listing}[h] 
	\begin{minted}{bash}
|--publisher
|   |-- lib
|   |   |-- Metadata
|   |   |   |-- Consumer.pm
|   |   |   |-- test.pl
|   |   |--- Net
|   |   |   |-- RTCP
|   |   |   |   |-- Packet.pm
|   |   |   |-- RTCP.pm
|   |   |   |-- RTP
|   |   |   |   |-- Packet.pm
|   |   |   |-- RTP.pm
|   |   |-- PubSub
|   |       |-- Util.pm
|   |-- metadata_example.json
|   |-- pipe_size.c
|   |-- producer.pl -> ../producer/dummy_producer.pl
|   |-- publisher.pl
|   |-- test.pl
|   |-- very_dummy_producer.sh
|--subscriber
|   |-- consumer.sh
|   |-- lib -> ../publisher/lib
|   |-- subscriber.pl

	\end{minted}
\caption{Listing shows how tcpdump is run to record RTP and RTCP packets. Port 5004 and 5005 is used for RTP and RTCP respectively}
\label{cmd:implementation:tcpreplay}
\end{listing}
\todo{Fix command}

\section{Metadata profile} \label{sec:implemented:metadataprofile} 
A profile must be defined, in order to define a new set of parameters for the RTP packet, in order to use the RTP to carry metadata and events. These parameters are listed below:

\begin{itemize}
	\item \textbf{Packet type}: In the metadata profile, the \textit{Packet type}-field will be used to tell which format the metadata is in. Only two  dataformats are defined, however the RTP profile allows up to $2^7=128$  packet types.
		\begin{itemize}
			\item 0: SDP file. the payload of the RTP packet is in the SDP format.
			\item 1: Non-essential metadata. The payload of the RTP packet is a dump of a perl hashmap. This allows a sender to dump a hashmap of key-value pairs and reconstruct the hashmap on the recipient.
			\item 2: JSON. The payload of the RTP packets are JSON encoded. Each RTP packet contain valid JSON encoded data.
		\end{itemize}
	\item \textbf{Marker bit}: The \textit{Marker}-bit is used to denote whether the RTP packet announces a new frame or provides metadata.
		\begin{itemize}
			\item 0, the RTP packet announces a stream. How the payload is encoded is specified by the \textit{Packet Type}-field.
			\item 1, the RTP packet contains an event. How the content of the packet is encoded is specified by the \textit{Packet Type}-field.
		\end{itemize}
	\item \textbf{32 bit timestamp}
\end{itemize}




\section{Software Components}
The following examples are made in order to show the modularity of the system:



\begin{listing}[h] 
\begin{minted}{python}
	eventHandler = eventLoop()
	
	timerX = Timer(X, callback_Xsec)
	timerY = Timer(Y, callback_Ysec)
	
	eventHandler.add(timerX)
	eventHandler.add(timery)
	
	stream_wellknown    = getStream(fd, callback_wellknown)
	stream_source       = getStream(fd, callback_source)
	stream_sourcepipe   = getStream(source_pipe, callback_sourcepipe)
	stream_metadatapipe = getStream(metadata_pipe, callback_metadatapipe)	
	
	eventHandler.add(stream_wellknown)
	eventHandler.add(stream_source)
	eventHandler.add(stream_sourcepipe)
	eventHandler.add(stream_metadatapipe)
	
	eventHandler.run()
\end{minted}
\caption{Critical section for copying counter value. C version.}
\label{code:critical_section_c}
\end{listing}



\section{Test}
From wireshark after resample:
4096 = payload
8 bytes = data gram
12 bytes rtp header

4116 bytes i total

Compare output of stream with snapshot-file
Write 1XXXE and verify with wireshark dissector
    - in table with output
Two subscribers to one stream - compare data. \# samples, md5 of files.
Record and replay, plot to verify data
Compare RTCP abs. timestamp with expected timestamp form RTP samples.



\section{Ipv6}
   IPv6 sessions are announced on the address FF0X:0:0:0:0:0:2:7FFE
      where X is the 4-bit scope value.  For example, an announcement
      for a link-local session assigned the address
      FF02:0:0:0:0:0:1234:5678, should be advertised on SAP address
      FF02:0:0:0:0:0:2:7FFE.
      

Generation of random IPv6:
Last part of IPv6:
::XXXX = 16 bits
$2^16 = 65536$
 \todo{Compare gstreamer with custom impl.}

\input{sections/verification}

