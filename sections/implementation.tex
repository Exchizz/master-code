\chapter{Implementation} \label{chp:implementation}
This chapter will describe the implementation of the \pub{} and \sub{} as designed in the chapter \ref{chp:design}. In section \ref{sec:verification}, the requirements from the 

\section{Software Components}
\subsection{RTP/RTCP}

\todo{Add in impl. introduction that pub/sub are implemented in perl}

In order for the \pub{} and \sub{} to support sending and receiving RTP and RTCP messages, two C libraries has been compared. As perl has support for wrapping C into shared modules that can be run with a perm module, C has been used.

Two C libraries are compared:

\myparagraph{oRTP} 
The oRTP library is used in \textit{linphone Open-source VoIP}, which is an open-source VoIP solution created and maintained by Belledonne Communications. The oRTP library is released under the GNU GPLv2 and proprietary license meaning the library can be used for open-source projects and in proprietary solutions.
The oRTP library implements RFC3550 with an API that offers a high as well as low level interfacing for sending and receiving RTP and RTCP packets and parsing and composing RTP and RTCP packets. It supports multiple RTP sessions with IPv4 and IPv6 unicast and multicast. Furthermore, it offers support for different profiles, meaning a custom profile can be implrunmodeemented.  oRTP has a sparse documentation with only an autogenerated doxygen, where most of the functionality is described. The source-code comes with simple examples, that explains some of the library's functionality. The library is written in C and can be found in Ubuntu and Debian's packet repository. At the time of writing, the latest commit on their official github has been made 24 days ago which indicates the project is active. In CPAN, an oRTP library can be found, that implements some of the most high level API functions.


\myparagraph{jrtplib}
The jrtplib library is developed at the the Expertise Centre for Digital Media (EDM), a research institute of the Hasselt University. At the time of writing the library has been used in 61 projects listed on \href{http://research.edm.uhasselt.be/jori/cgi-bin/listprojects.py?name=jrtplib}{Project list}. The library is free to use, but must include disclaimer in the source code. The library implements RFC3550 and provides primarily a high level API, that hides most of the implementation details. The library supports parsing, composing, sending and receiving RTP and RTCP messages but does not not implement any profile, The library is written in C++ and well-documented by giving a thoroughly \textit{Getting Started} and includes 7 examples showing how to utilize the functionality of the library. Unfortunately, at the moment of writing the maintainers have not done any commits for the past year.

The libraries are compared based on the following requirements:
\begin{itemize}
	\item \textit{In repository}: From design requirement 4, the library should, if possible, be in the Debian repository.
	\item \textit{RTCP impl.}: The library should implement RTCP, as RTCP is required by the \pub{} and \sub{}.
	\item \textit{Low level API}: As the \pub{} and \sub{} should send RTCP SDEs, RTCP, BYE and RTCP SR.
	\item \textit{Custom RTP Profile}: The library should allow using a custom profile, as the \pub{} and \sub{} requires a custom profile for the non-essential/essential metadata.\todo{Verify requirement}
	\item \textit{API documented}: Preferable to ease implementation of the \pub{} and \sub{}
	\item \textit{Actively Maintained}: Relatively important, in case bugs are discovered.
	\item \textit{IPv6/4 multicast support}: Required by requirement X \todo{Analysis requirement}
	\item \textit{Existing per-binding}: As the \pub{} and \sub{} will be implemented in perl, existing bindings are preferable to ease implementation.
	\item \textit{Multiple RTP session}: Required by design requirement X
	\item \textit{Send \& Receive RTP/RTCP}: is required by \pub{} and \sub{}, respectively.
	\item \textit{Includes examples}: Preferable as it eases implementation.
\end{itemize}

\begin{table}[H]
\centering
\begin{tabular}{@{}|l|l|l@{}|}
\hline
\multicolumn{1}{|l|}{\textbf{Library property}} & \multicolumn{1}{|l|}{\textbf{oRTP}}         & \multicolumn{1}{|l|}{\textbf{jrtplib}}       \\ \midrule
\multicolumn{1}{|l|}{In repository}    & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{l|}{} \\ \midrule
\multicolumn{1}{|l|}{RTCP impl.} & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{Low level API} & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{} \\ \midrule
\multicolumn{1}{|l|}{Custom RTP Profile} & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{} \\ \midrule
\multicolumn{1}{|l|}{API documented}          & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{Actively Maintained}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{l|}{} \\ \midrule
\multicolumn{1}{|l|}{IPv6 multicast support}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{IPv4 multicast support}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{Existing perl-binding}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{} \\ \midrule
\multicolumn{1}{|l|}{Multiple RTP sessions support}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{Send \& Receive}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark} \\ \midrule
\multicolumn{1}{|l|}{Includes examples}           & \multicolumn{1}{c|}{\checkmark} & \multicolumn{1}{c|}{\checkmark}  \\ \bottomrule
\end{tabular}
\caption{Comparesion of oRTP and jrtplib}
\label{sec:implementation:rtplib}
\end{table}

Based on the number of checkmarks in table \ref{sec:implementation:rtplib}, it has been chosen to use the oRTP library.

\todo{File tree, describe common perl library}
\subsection{Publisher \& Subscriber}

\textit{P1: The \pub{} should be the logical master of the \pro{}}\\
\textit{S1: The \sub{} should be the logical master of the \pro{}}\\

From requirement P1,S2 the \pub{} and \sub{} being the logical masters has been implemented by passing the path to the \con{} and \pro{} to the \sub{} and \pro{} respectively as an argument. This design allows the \pub{} and \sub{} to pass the pipes to the \pro{} and \con{} during run of the \con{} and \pro{}, respectively.

\begin{listing}[H] 
\begin{minted}{python}
./publisher.pl --producer producer.pl
./subscriber.pl --producer consumer.pl
\end{minted}
\caption{Example of publisher.pl run with producer.pl as parameter}
\label{code:critical_section_c}
\end{listing}

This will result in the process tree as depicted in figure \ref{sec:implementation:runmode}.

\begin{listing}[H] 
\begin{minted}{python}
/usr/bin/perl publisher.pl --producer producer.pl
 \_ /usr/bin/perl producer.pl /tmp/pub_data_pipe /tmp/pub_metadata_pipe
 
 /usr/bin/perl subscriber.pl --consumer consumer.pl
 \_ /usr/bin/perl consumer.pl /tmp/pub_data_pipe /tmp/pub_metadata_pipe
\end{minted}
\caption{Example of publisher.pl run as logical master of the producer.pl}
\label{sec:implementation:runmode}
\end{listing}

By running the consumer and producers this way gives modularity in the way the programs can be run, and does not restrict how the \con{} and \pro{} should be implemented.
Three examples are shown, that show how the designed \pros{},\cons{}, \pros{} and \subs{} can be integrated with MCLURS and the streaming idea in section \ref{sec:streamingidea}.

\myparagraph{Grab with static metadata file}
If \program{Grab} is used to deliver data, the programs can be connected as shown in listing \ref{lst:implementation:grab}.

\begin{listing}[H] 
\begin{minted}{bash}
#!/bin/bash
# Named pipes passed as parameters
DATA_PIPE=$1
MD_PIPE=$2

# Provide feedback to the user
echo "Starting producer"

# Set non-essential metadata to Publisher
cat metadata_example.json > $MD_PIPE

# Capture samples and write to datapipe with Fs of 250kHz
/usr/bin/grab -f 2500000 > $DATA_PIPE
\end{minted}
\caption{The listing shows an implementation of a \pro{} that writes metadata and samples to the datapipe and metadatapipe, respectively}
\label{lst:implementation:grab}
\end{listing}

Listing \ref{lst:implementation:grab} shows how the \pro{} could be integrated with \program{grab}.
Metadata is provided by reading the \textit{metadata\_example.json}, and writing it to the metadatapipe.
As \program{grab} does not provide timing of the samples, no RTCP SR messages can be sent.


\myparagraph{Snapshot with dynamic metadata}
In order to use the \pub{} with \program{Snapshot}, the \pro{} must instruct \program{Snapshot} to do repeating snapshots. Furthermore, the \program{Snapshot} must be told where it should write the streams to. This is should in listing \ref{lst:implementation:snapshot1}.
\todo{Describe RTCP SR packet}

\begin{listing}[H] 
\begin{minted}{python}
# Named pipes passed as parameters
DATA_PIPE=$1
MD_PIPE=$2

open MD_PIPE
write essentialMetadata.json to MD_PIPE

snapshot = ZMQ(SNAPSHOT)
snapshot.setup()
snapshot.start()
snapshot.snap(start=0,length=4096,count=100,stream=\$1)

PeriodicRun(1, updateNonessentialMetadata());


def getNonessentialMetadata():
	metadata = snapshot.getNonessentialMetaData()
	write metadata to MD_PIPE
	
\end{minted}
\caption{The listing shows an implementation of a \pro{} that writes metadata and samples to the datapipe and metadatapipe, respectively}
\label{lst:implementation:snapshot1}
\end{listing}

From design requirement X, the RTCP SR packets must be sent in order to timestamp the data stream. In order to do this, \program{Snapshot} supports ZMQ clients to query for timing information. When a \textit{Ztatus} command\footnote{Command implemented by the \program{Snapshot} daemon} is received, it sends a reply of the following format:


\begin{listing}[H] 
\begin{minted}{python}
OK Ztatus: WRITER Files 0, Xfr space 49152[ki spl]
READER ACTIVE hix: 0x0000000000824800 [spl]\ 
  tix: 000000000000000000 [spl] now: 0x00002c8008e4ee1e [ns]
\end{minted}
\caption{The listing shows an implementation of a \pro{} that writes metadata and samples to the datapipe and metadatapipe, respectively}
\label{lst:implementation:snapshot1}
\end{listing}


\begin{itemize}
	\item Filter
	\item Grab with metadata from file
	\item Consumer taking data from snapshot and providing dynamic metadata
\end{itemize}


\myparagraph{Inter-Process Communication}
From implementation requirement P2/S2, the non-essential and essential metadata should be passed between the \pub{}/\sub{} and the \con{}/\pro{} using pipes. Three types of pipes are considered:
\begin{itemize}
	\item Named pipe: Named pipes or FIFO pipes in linux usually appear as files, which processes can read from and write to as part of \ac{IPC}. Named pipes are uni-directional, as one process opens the pipe for writing, and another process opens for reading. Having multiple readers from the named pipe is not supported.
	
	\item Unnamed pipe: Unamed pipes are used in linux to chain input/output between processes. As with named pipes, unamed pipes are uni-direction. This is implemented such that standard output(stdout) from one process, is attached to standard in(stdin) to the next process in the chain. As with named pipe, no framing is required.
	
	\item UNIX socket: UNIX sockets work similar to network sockets in linux, but only locally. Many clients can connect to the same server using the UNIX sockets. A UNIX socket appear like a named pipe, as a file. The UNIX socket supports bi-directional communication. 
\end{itemize}

If the \pub{} should use unnamed pipes, an unnamed pipe should be created that attach the unnamed pipe to stdout from the \pro{}, such that data printed from the \pro{} would show up at the other end of the pipe, read by the \pub{}. Another unnamed pipe could be created, that would be attached to standard error(stderr), in order to have two communication channels to pass non-essential/essential metadata and data to the \pub{}. However this design does not allow the \pro{} to generate output, which could be helpful in development, testing and debugging of \cons{}. The same could be applied to the \sub{} and \con{}; however only one communication channel is available from the \sub{} to the \con{}, which is not enough in order to provide essential/non-essential and data to the \con{}.

Unix pipes are not used, as bidirectional communication is not needed. Due to simplicity and using existing linux functionality, the communication between the \pubs{} \subs{} and \con{} and \pro{} is created using named pipes.


\subsection{Publisher}
\subsection{Subscriber}
%\subsection{Runmode}


\section{Metadata}
Metadata must be provided by the \pro{}, as the \pro{} should be implemented to collect essential and non-essential metadata.


\section{Historian}
As described in section \ref{sec:design:historian}, \program{tcpdump/tcpreplay} is used as \hist{}.
In order to record RTP and RTCP packets, \program{tcpdump} is shown in listing \ref{cmd:implementation:tcpdump}.
\begin{listing}[h] 
\begin{minted}{bash}
tcpdump -i interface -w /tmp/filedump.pcap dst port 5004 or dst port 5005 
\end{minted}
\caption{Listing shows how tcpdump is run to record RTP and RTCP packets. Port 5004 and 5005 is used for RTP and RTCP respectively}
\label{cmd:implementation:tcpdump}
\end{listing}


For replaying a recording, \program{tcpreplay} is used as showed in listing \ref{cmd:implementation:tcpreplay}.
\begin{listing}[h] 
	\begin{minted}{bash}
tcpreplay.....
	\end{minted}
\caption{Listing shows how tcpdump is run to record RTP and RTCP packets. Port 5004 and 5005 is used for RTP and RTCP respectively}
\label{cmd:implementation:tcpreplay}
\end{listing}
\todo{Fix command}


The file tree of the \pub{} and \sub{} is shown in listing \ref{lst:implementation:tree}.
\begin{listing}[h] 
	\begin{minted}{bash}
|--publisher
|   |-- lib
|   |   |-- Metadata
|   |   |   |-- Consumer.pm
|   |   |   |-- test.pl
|   |   |--- Net
|   |   |   |-- RTCP
|   |   |   |   |-- Packet.pm
|   |   |   |-- RTCP.pm
|   |   |   |-- RTP
|   |   |   |   |-- Packet.pm
|   |   |   |-- RTP.pm
|   |   |-- PubSub
|   |       |-- Util.pm
|   |-- metadata_example.json
|   |-- pipe_size.c
|   |-- producer.pl -> ../producer/dummy_producer.pl
|   |-- publisher.pl
|   |-- test.pl
|   |-- very_dummy_producer.sh
|--subscriber
|   |-- consumer.sh
|   |-- lib -> ../publisher/lib
|   |-- subscriber.pl

	\end{minted}
\caption{Listing shows how tcpdump is run to record RTP and RTCP packets. Port 5004 and 5005 is used for RTP and RTCP respectively}
\label{cmd:implementation:tcpreplay}
\end{listing}
\todo{Fix command}

\section{Metadata profile} \label{sec:implemented:metadataprofile} 
A profile must be defined, in order to define a new set of parameters for the RTP packet, in order to use the RTP to carry metadata and events. These parameters are listed below:

\begin{itemize}
	\item \textbf{Packet type}: In the metadata profile, the \textit{Packet type}-field will be used to tell which format the metadata is in. Only two  dataformats are defined, however the RTP profile allows up to $2^7=128$  packet types.
		\begin{itemize}
			\item 0: SDP file. the payload of the RTP packet is in the SDP format.
			\item 1: Non-essential metadata. The payload of the RTP packet is a dump of a perl hashmap. This allows a sender to dump a hashmap of key-value pairs and reconstruct the hashmap on the recipient.
			\item 2: JSON. The payload of the RTP packets are JSON encoded. Each RTP packet contain valid JSON encoded data.
		\end{itemize}
	\item \textbf{Marker bit}: The \textit{Marker}-bit is used to denote whether the RTP packet announces a new frame or provides metadata.
		\begin{itemize}
			\item 0, the RTP packet announces a stream. How the payload is encoded is specified by the \textit{Packet Type}-field.
			\item 1, the RTP packet contains an event. How the content of the packet is encoded is specified by the \textit{Packet Type}-field.
		\end{itemize}
	\item \textbf{32 bit timestamp}
\end{itemize}




\section{Software Components}
The following examples are made in order to show the modularity of the system:



\begin{listing}[h] 
\begin{minted}{python}
	eventHandler = eventLoop()
	
	timerX = Timer(X, callback_Xsec)
	timerY = Timer(Y, callback_Ysec)
	
	eventHandler.add(timerX)
	eventHandler.add(timery)
	
	stream_wellknown    = getStream(fd, callback_wellknown)
	stream_source       = getStream(fd, callback_source)
	stream_sourcepipe   = getStream(source_pipe, callback_sourcepipe)
	stream_metadatapipe = getStream(metadata_pipe, callback_metadatapipe)	
	
	eventHandler.add(stream_wellknown)
	eventHandler.add(stream_source)
	eventHandler.add(stream_sourcepipe)
	eventHandler.add(stream_metadatapipe)
	
	eventHandler.run()
\end{minted}
\caption{Critical section for copying counter value. C version.}
\label{code:critical_section_c}
\end{listing}



\section{Test}
From wireshark after resample:
4096 = payload
8 bytes = data gram
12 bytes rtp header

4116 bytes i total

Compare output of stream with snapshot-file
Write 1XXXE and verify with wireshark dissector
    - in table with output
Two subscribers to one stream - compare data. \# samples, md5 of files.
Record and replay, plot to verify data
Compare RTCP abs. timestamp with expected timestamp form RTP samples.

\section{Timing in RTCP packets}
\begin{align}
	mon_1 &= Monotonic time \\
	realtime &= now \\
	mon_2 &= Monotonic time \\
	offset &= realtime-(mon_1+mon_2)/2 
\end{align}


\section{Ipv6}
   IPv6 sessions are announced on the address FF0X:0:0:0:0:0:2:7FFE
      where X is the 4-bit scope value.  For example, an announcement
      for a link-local session assigned the address
      FF02:0:0:0:0:0:1234:5678, should be advertised on SAP address
      FF02:0:0:0:0:0:2:7FFE.
      

Generation of random IPv6:
Last part of IPv6:
::XXXX = 16 bits
$2^16 = 65536$
 \todo{Compare gstreamer with custom impl.}


\section{Gstreamer}
Gstreaner is a open source tool available, that implements some of the protocols described in section \ref{sec:design:protocols}.
\todo{Describe gstreamer + pros and cons}
Cons:
 - 64bit timestamp injected
 - Does not handle multicast address assignment
Gstreamer is a pipeline based streaming framework that aims to make it easy to work with streams. Gstreamer is plugin based which allows for adding functionality as needed in applications. The idea of plugins is to create plugins are have a well defined responsibility such as reading a file, encoding, playing etc. The plugins are usually connected in gstreamer pipelines, however then can be used in independent applications. Gstreamer plugins are connected using pads, where each plugin can have a source and sink pad. A source pad can then be connected to the next plugin's sink pad. An example of plugins in a pipelines is showed below:
\begin{figure}
	\includegraphics[width=1\textwidth]{figures/bin-element-ghost.png}
\end{figure}

\todo{Describe example figure + rtpbin + rtppay/depay}

\todo{Describe dummy producer.pl}
\section{Only permit one publisher pr. stream}

The test has been conducted by first starting one instance of \program{Publisher} and when it starts to publish data, then a second instance of the \program{Publisher}. Both \program{Publishers} have been given the same highbandwidth IPv6 multicast address, namely FF15::1234.

Listing \ref{lst:implementation:uniquepub1} shows the output from the first \program{Publisher}.

\begin{lstlisting}
Random ip: ff15::1234
Verbose: 5
Executable: producer.pl
"producer.pl" is readable
"producer.pl" is exeutable
Data pipe: /tmp/pipe_publisher_data metadata pipe:/tmp/pipe_publisher_metadata
Waitfor: duration 5.000000 and interval 1.000000
Callback invoked...
Waitfor: wake from sleep at elapsed 1.000000
Callback invoked...
Waitfor: wake from sleep at elapsed 2.000000
Callback invoked...
Waitfor: wake from sleep at elapsed 3.000000
Callback invoked...
Waitfor: wake from sleep at elapsed 4.000000
Callback invoked...
Waitfor: wake from sleep at elapsed 5.000000
Waitfor: loop completed, elapsed 5.000000 of 5.000000
No IPv6 multicast conflict
\end{lstlisting} \label{lst:implementation:uniquepub1}

Listing \ref{lst:implementation:uniquepub2} shows the output from the second instance of the \program{Publisher}.

\begin{lstlisting}
Random ip: ff15::1234
Verbose: 4
Executable: producer.pl
"producer.pl" is readable
"producer.pl" is exeutable
Data pipe: /tmp/pipe_publisher_data metadata pipe:/tmp/pipe_publisher_metadata
Waitfor: duration 5.000000 and interval 1.000000
Callback invoked...
ff15::1234 vs. ff15::1234
Waitfor: loop completed, elapsed 1.000000 of 5.000000
Ipv6 multicast group conflict
New random IPv6 multicast ip: ff15::8a12
Waitfor: duration 5.000000 and interval 1.000000
Callback invoked...
ff15::1234 vs. ff15::8a12
Callback invoked...
ff15::1234 vs. ff15::8a12
Callback invoked...
ff15::1234 vs. ff15::8a12
Callback invoked...
ff15::1234 vs. ff15::8a12
Callback invoked...
ff15::1234 vs. ff15::8a12
Waitfor: loop completed, elapsed 5.000000 of 5.000000
No IPv6 multicast conflict
\end{lstlisting}\label{lst:implementation:uniquepub2}


\input{sections/verification}

